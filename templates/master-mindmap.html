{% extends "index.html" %}

{% block content %}
<div class="post">
    <div class="post-content">
        {{ page.content | safe }}

        <div id="graphDiv"></div>
    </div>
</div>

<script src="https://bumbu.me/svg-pan-zoom/dist/svg-pan-zoom.min.js"></script>
<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ 
        startOnLoad: false,
        theme: 'dark',
        themeVariables: {
            primaryColor: '#ff9800',
            primaryTextColor: '#ffffff',
            primaryBorderColor: '#ff9800',
            lineColor: '#ff9800',
            secondaryColor: '#1a1a1a',
            tertiaryColor: '#333333',
            background: '#121212',
            mainBkg: '#1a1a1a',
            secondBkg: '#333333'
        }
    });

    const drawDiagram = async function () {
        const element = document.querySelector('#graphDiv');
        const graphDefinition = `
mindmap
  root((Research Questions on Loudspeaker Modeling))
    Theory and Discovery
      Structure discovery
        Q1 Analytical discovery
        Q6 Nonlinear mechanism isolation
        Q7 Physical interpretability
      Cross-domain coupling
        Q13 Thermo-electro-mechanical coupling
        Q33 Electromagnetic hysteresis and eddy currents
      Control-centric modeling
        Q32 Feedback linearization
    Thermal Effects
      Parameters and estimation
        Q14 Online voice-coil temperature estimation
        Q15 LPV scheduling on temperature
      Separation and excitation
        Q16 Excitation design for separating thermal and fast nonlinearities
      Prediction and impact
        Q41 Predictive usefulness for long-term performance
        Q19 Thermo-mechanical interplay with LPV on x and T
    Hysteresis and Creep
      Model families
        Q17 Hysteresis model class (fractional, Bouc-Wen, Preisach)
        Q28 Time-domain viscoelastic creep modeling
        Q29 Mapping frequency-domain viscoelastic to time-domain
      Phenomenology and tests
        Q18 Rate effects versus memory
      Practical identification
        Q20 Identifiability with u, i, x only
    Materials and Structures
      Youngs modulus
        Q23 Dynamic modulus extraction
        Q24 Cone and edge modulus effects
        Q25 Modulus variability with temperature and aging
        Q34 Oberst-bar modulus for modeling
      Structural limits
        Q35 Surround buckling limits
      Aging and drift
        Q30 Early run-in drift
        Q31 Long-term material aging effects
        Q38 Spider and surround modal tuning personalization
    System Identification Methods
      Linear baselines
        Q4 N4SID and PEM as baselines
        Q10 Compare polynomial, Volterra, neural models
      Gray-box and black-box
        Q2 Gray-box modeling
        Q3 Universal approximators
      Data and robustness
        Q8 Data efficiency
        Q9 Robust or Bayesian estimation
        Q47 Generalization across drivers
      Experiment design
        Q16 Excitation strategy
        Q20 Practical identifiability constraints
    Multiphysics and Simulation
      Validation and fidelity
        Q26 Validate coupled FEM model
        Q37 Complex modulus extraction via FE fitting
      Hybrid modeling and optimization
        Q27 Hybrid FE and lumped models
      Loss models
        Q36 Viscous versus hysteretic damping
    Nonlinear and Large-Signal Behavior
      Modeling and optimization
        Q39 Large-signal nonlinear optimization
      Spatial measurement
        Q40 Real-time cone shape distortion
      Electromagnetic nonlinearities
        Q33 Magnetic hysteresis and eddy currents
    Usefulness and Applications
      Design decisions
        Q42 Design usefulness
      Control and deployment
        Q43 Control integration
        Q48 Computational efficiency
        Q49 Scalability to multiway systems
      Diagnostics and reliability
        Q44 Fault detection
        Q41 Long-term performance prediction
      Standards and communication
        Q50 Usability in standards
    Model Qualities
      Trade-offs
        Q45 Interpretability versus accuracy
      Robustness
        Q46 Robustness to environment and signals
        Q47 Generalization across devices
      Efficiency
        Q48 Computational cost versus accuracy
    Evaluation and Meta
      Frameworks and metrics
        Q5 Unified evaluation framework
      Cross-system tests
        Q12 Cross-loudspeaker generalization
      Interactions
        Q21 Materials and geometry versus thermal and creep
        Q22 Control with temperature and hysteresis
        `;
        const { svg } = await mermaid.render('mySvgId', graphDefinition);
        element.innerHTML = svg.replace(/( )*max-width:( 0-9\.)*px;/i, '');

        var doPan = false;
        var eventsHandler;
        var panZoom;
        var mousepos;

        eventsHandler = {
            haltEventListeners: ['mousedown', 'mousemove', 'mouseup']

            , mouseDownHandler: function (ev) {
                if (event.target.className == "[object SVGAnimatedString]") {
                    doPan = true;
                    mousepos = { x: ev.clientX, y: ev.clientY }
                };
            }

            , mouseMoveHandler: function (ev) {
                if (doPan) {
                    panZoom.panBy({ x: ev.clientX - mousepos.x, y: ev.clientY - mousepos.y });
                    mousepos = { x: ev.clientX, y: ev.clientY };
                    window.getSelection().removeAllRanges();
                }
            }

            , mouseUpHandler: function (ev) {
                doPan = false;
            }

            , init: function (options) {
                options.svgElement.addEventListener('mousedown', this.mouseDownHandler, false);
                options.svgElement.addEventListener('mousemove', this.mouseMoveHandler, false);
                options.svgElement.addEventListener('mouseup', this.mouseUpHandler, false);
            }

            , destroy: function (options) {
                options.svgElement.removeEventListener('mousedown', this.mouseDownHandler, false);
                options.svgElement.removeEventListener('mousemove', this.mouseMoveHandler, false);
                options.svgElement.removeEventListener('mouseup', this.mouseUpHandler, false);
            }
        }
        panZoom = svgPanZoom('#mySvgId', {
            zoomEnabled: true
            , controlIconsEnabled: true
            , fit: 1
            , center: 1
            , customEventsHandler: eventsHandler
        })
    };
    await drawDiagram();
</script>

<style>
#mySvgId {
    height: 90%;
    width: 100%;
}

#graphDiv {
    height: 700px;
    width: 100%;
    border: 1px solid var(--accent);
    border-radius: 8px;
    margin: 20px 0;
    background: var(--background);
}
</style>
{% endblock content %}